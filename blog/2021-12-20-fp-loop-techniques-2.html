<h2 id="a-recipe-to-transform-loops-into-recursive-functions">A recipe to transform loops into recursive functions</h2>
<p>If you think about a loop as a statement that is repeatedly executed adapting parameters such as an index or storing something in an accumulator parameter, it is fairly clear that you can express this easily via recursion. The function just has to call itself in the end with the adapted parameters and return the final state when reaching the break condition. Here is how to a loop translates into a recursive function:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;number&quot;</span>, i)</span></code></pre></div>
<p>This becomes</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterator(index):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> index <span class="op">==</span> <span class="dv">10</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(index)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      iterator(index <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>Calling <code>iterator(0)</code>, essentially executes the same loop the previous. This technique can easily translate every loop.</p>
<h2 id="transforming-recursive-functions-into-loops-tail-recursion">Transforming recursive functions into loops: tail recursion</h2>
<p>A second thing is interesting: whereas a traditional loop can end with <code>break</code> or a similar statement, the recursive version now suddenly specifies a return value. It is an expression now that can be evaluated to a simple value. But how about a loop with accumulator?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>var <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> var <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    var <span class="op">+=</span> <span class="dv">2</span></span></code></pre></div>
<p>Here is the same loop written as recursion:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterator(state)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> state <span class="op">==</span> <span class="dv">10</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      iterator(state <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>iterator(<span class="dv">0</span>)</span></code></pre></div>
<p>In fact, <em>every</em> loop decomposes into a state variable, a break condition and an initial value. This means that we can also express <em>every</em> loop with recursion and that even without modifying any external state. To translate any <code>while</code> or <code>for</code> loop into a recursive function, you simply need to identify the state variables, the variables that are modified from within the loop plus the index variable in <code>for</code> loops, and the break condition and plug them into the preceding snippet. The function should return the state when the break condition hits and modify and pass on the state to itself recursively otherwise. The state is then passed from function to function call until the break condition triggers a return statement.</p>
<p>As there is a recipe from <code>while</code> loops to recursion, in certain conditions, there is also one back. If you think back about our description you can think about a <code>for</code> or <code>while</code> loop as a function executing the same statements as the loop, modifying some state variable and then calling itself with the modified state until reaching a break condition. This means that whenever the function calls itself in the <em>last</em> position, it is very easy to translate it into a <code>while</code> loop. The term for this situation is <em>tail call optimization</em> and many compilers from the functional programming world know how to do this automatically. Here is an example in Python.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterator(acc, start, end):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> start <span class="op">==</span> end:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> acc </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        acc.append(start)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> iterator(acc, start<span class="op">+</span><span class="dv">1</span>, end)</span></code></pre></div>
<p>This prints:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(iterator([], <span class="dv">0</span>, <span class="dv">20</span>))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="dv">19</span>]</span></code></pre></div>
<p>This is definitely a tail recursive function in the <code>else:</code> part since we simply call itself with modified state. Therefore, we can easily translate this back to a <code>while</code> loop:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>end <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>acc <span class="op">=</span> []</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> start <span class="op">!=</span> end:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    acc.append(start)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> start <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(acc)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(acc)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>, <span class="dv">18</span>, <span class="dv">19</span>]</span></code></pre></div>
<p>Now, recursion might be able to express everything that <code>for</code> or <code>while</code> loops can express as well, but it is just more clunky. And this is where the real art starts. As with so many things in computation, the question is not whether I can in principle express something with a construct, but whether I can express it in an elegant and intuitive way. Functional programming has its own constructs to simplify loops and, as in imperative programming, it is rarely required to actually use recursion for common tasks. We’ll go into those techniques in the following sections.</p>
<h2 id="fix-points-and-recursion">Fix points and recursion</h2>
<p>Besides tail recursion, we can look on recursion from another perspective. Imagine writing out a recursive function such as the following:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> s <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>We can write this as recursive function</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(index):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> index <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> f(index<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> index</span></code></pre></div>
<p>If we write this recursion out, we essentially get:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> f(f(f(f(f(<span class="dv">0</span>)))))</span></code></pre></div>
<p>Looping means, from this perspective, reapplying a function to itself many times. This brings up the idea of writing a loop function that takes a function and applies it to itself:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fakefor(func, init, start, end):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        init <span class="op">=</span> func(init)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> init</span></code></pre></div>
<p>Functional programming has a function <code>fix</code> that is quite similar to <code>fakefor</code> that repeats a function infinitely <em>until the function hits a fixed point</em>, that is until the argument doesn’t change anymore. The strange thing is, that allowing this higher order function <code>fakefor</code> that hides an interior <code>for</code> or <code>while</code> loop, we can express any loop <em>even without any recursion</em>.</p>
